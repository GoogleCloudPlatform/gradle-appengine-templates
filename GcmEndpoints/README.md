"App Engine Backend with Google Cloud Messaging" Template
===========================================

[Google Cloud Messaging](http://developer.android.com/google/gcm) (GCM) is a service that allows you to send push notifications from your server to your users' Android devices, and also to receive messages from devices on the same connection. The GCM service handles all aspects of queueing of messages and delivery to the target Android application running on the target device.

This backend template employs [Google Cloud Endpoints](https://developers.google.com/appengine/docs/java/endpoints) to to define a RESTful API which registers Android devices with your GCM server and allows you to send string messages to registered devices. After defining this API, strongly-typed client libraries are generated automatically and can be called from your Android app, as described below.

# 1. Adding a backend in Android Studio

To add the backend to your existing Android app from this backend template, open Android Studio ([installation instructions](https://developer.android.com/sdk/installing/studio.html)) and navigate to "File &rarr; New Module..." or right-click on your project and choose "New &rarr; Module".

![New &rarr; Module](/doc/img/add-app-engine-backend-menu-scaled.png)

In the "New Module" wizard that appears, choose "Google Cloud Module":

![Add App Engine Backend Choose Module](/doc/img/choose_module.png)

Then choose "App Engine Backend with Google Cloud Messaging".

![App Engine GCM Module](/doc/img/gcm2.png)

Enter the module/package names for your new backend, and choose the "client" module in your project which contains your Android app. The client module will be set up to call your newly generated backend. Module name which you've entered above (marked with red **1**) will be used in your Android Studio project. Package name (marked with red **2**) will be used for all classes imported from this template and (reversed) for [Endpoints API namespaces](https://developers.google.com/appengine/docs/java/endpoints/annotations#apinamespace). In turn, Endpoints API namespaces will be used to derive the name of the autogenerated Android client libraries, hence this ensures that the names of generated client libraries will match your package name.

![Added "GcmEndpoints" backend. Red numbers 1 and 2 indicate that the module name and the package names came from "New App Engine Module" dialog](/doc/img/added-backend-gcm.png)

## 1.1. Debugging the backend locally

As soon as the backend module is added to your project and Gradle sync finishes, a new run configuration with your backend's module name should be created:

![Created run configuration](/doc/img/run-configuration.png)

Rebuild your project (via "Build &rarr; Rebuild Project") and launch this run configuration. It will invoke `appengineRun` task in [Gradle plug-in for App Engine](https://github.com/GoogleCloudPlatform/gradle-appengine-plugin), which in turn will start the local App Engine [Java development server](https://developers.google.com/appengine/docs/java/tools/devserver).

To ensure that your backend started successfully, navigate to [http://localhost:8080](http://localhost:8080). If everything went well, you should see the following page:

!["HelloWorld" backend running in local Java development server](/doc/img/devappserver-gcm.png)

# 2. Connecting your Android app to the backend

## 2.1. Obtaining Google Cloud Messaging API key

Before testing the application, you will need to obtain a Google Cloud Messaging API key. Open the `<backend>/src/main/webapp/WEB-INF/appengine-web.xml` file (it should have been opened by default when you generated the backend), and navigate to this link: [https://console.developers.google.com/flows/enableapi?apiid=googlecloudmessaging&keyType=SERVER_SIDE&r=0.0.0.0/0](https://console.developers.google.com/flows/enableapi?apiid=googlecloudmessaging&keyType=SERVER_SIDE&r=0.0.0.0/0).

![Project creation in Google Developers Console](/doc/img/new-developer-console-project-flow.png)

Choose a "Create a new project" option to create a new [Google Developers Console](https://console.developers.google.com) project (or choose an existing project, if you have one already), and click "Continue".

Once you select or create a project, it will have "Google Cloud Messaging for Android" API enabled automatically. In the following configuration dialog, you can use the supplied "0.0.0.0/0" IP address for testing purposes.

![Creating a new server key in Google Developers Console](/doc/img/developer-console-api.png)

Click "Create" to get the API key for server applications generated for you.

![Server applications API key in Google Developers Console](/doc/img/developer-console-key.png)

Copy the generated [API key](http://developer.android.com/google/gcm/gcm.html#apikey) (in a red rectangle, starts with `AIza...`) back into `appengine-web.xml` file, replacing
```xml
<property name="gcm.api.key" value="YOUR_KEY_HERE"/>
```
with
```xml
<property name="gcm.api.key" value="AIza..."/>
```

Finally, go back to your project's overview in [Google Developers Console](https://console.developers.google.com) and note down the project number (in red rectangle below): this will be your Google Cloud Messaging [sender ID](http://developer.android.com/google/gcm/gcm.html#senderid) in the next step.

![Project number in Google Developers Console](/doc/img/developer-console-project.png)

## 2.2. Registering devices with Google Cloud Messaging backend

Before any messages can be sent from a Google Cloud Messaging backend to the devices, these devices need to be registered with a GCM backend.

When you added this backend module to your project, the [required permissions, needed by Google Cloud Messaging](http://developer.android.com/google/gcm/client.html#manifest) have been added into the Android manifest of your app, and the required build dependencies have been added to your app's `build.gradle` file.

Furthermore, a `RegistrationEndpoint` [Cloud Endpoints API](https://developers.google.com/appengine/docs/java/endpoints/) has been automatically generated for you, so that you could start calling this endpoint from your Android app to register devices with your new Google Cloud Messaging backend.

Here is an example code snippet which illustrates how to create an [AsyncTask](http://developer.android.com/reference/android/os/AsyncTask.html) to register the user's device with your new backend:

```java
class GcmRegistrationAsyncTask extends AsyncTask<Context, Void, String> {
    private static Registration regService = null;
    private GoogleCloudMessaging gcm;
    private Context context;

    // TODO: change to your own sender ID to Google Developers Console project number, as per instructions above
    private static final String SENDER_ID = "1234567890123"; 

    @Override
    protected String doInBackground(Context... params) {
        if (regService == null) {
            Registration.Builder builder = new Registration.Builder(AndroidHttp.newCompatibleTransport(), 
                    new AndroidJsonFactory(), null)
                // Need setRootUrl and setGoogleClientRequestInitializer only for local testing,
                // otherwise they can be skipped
                .setRootUrl("http://10.0.2.2:8080/_ah/api/")
                .setGoogleClientRequestInitializer(new GoogleClientRequestInitializer() {
                    @Override
                    public void initialize(AbstractGoogleClientRequest<?> abstractGoogleClientRequest) 
                            throws IOException {
                        abstractGoogleClientRequest.setDisableGZipContent(true);
                    }
                });
                // end of optional local run code

            regService = builder.build();
        }

        context = params[0];

        String msg = "";
        try {
            if (gcm == null) {
                gcm = GoogleCloudMessaging.getInstance(context);
            }
            String regId = gcm.register(SENDER_ID);
            msg = "Device registered, registration ID=" + regId;

            // You should send the registration ID to your server over HTTP,
            // so it can use GCM/HTTP or CCS to send messages to your app.
            // The request to your server should be authenticated if your app
            // is using accounts.
            regService.register(regId).execute();

        } catch (IOException ex) {
            ex.printStackTrace();
            msg = "Error: " + ex.getMessage();
        }
        return msg;
    }

    @Override
    protected void onPostExecute(String msg) {
        Toast.makeText(context, msg, Toast.LENGTH_LONG).show();
        Logger.getLogger("REGISTRATION").log(Level.INFO, msg);
    }
}
```

Don't forget to replace `SENDER_ID` in the snippet above with your actual Google Developers Console project number!

To make the actual registration call from your app, invoke this AsyncTask from one of your Android activities. For example, to execute it from `MainActivity` class, add the following code snippet to `MainActivity.onCreate` method:

```java
new GcmRegistrationAsyncTask().execute(this);
```

## 2.3. Testing device registration in an emulator

If you have added an `GcmRegistrationAsyncTask` invokation to one of your Android app activities as per steps above (and replaced `SENDER_ID` with your actual Google Developers Console project number), you should be all set to test the device registration with your backend locally!

To begin with, make sure that your Android Virtual Device is using Google APIs System Image as illustrated in the screenshot below.

![Android Virtual Device configuration containing Google APIs System Image Target](/doc/img/emulator-avd.png)

Then, launch your backend locally as described in section 1.1. and ensure that you can access it via [http://localhost:8080](http://localhost:8080). If you can access the backend locally, change the run configuration back to your Android app and run the Android emulator.

If everything goes well, you should see the following toast in your app:

![Emulator successfully registered with "GcmEndpoints" backend](/doc/img/emulator-gcm.png)

## 2.4. Showing push notifications from GCM backend

In order to show the push notifications coming from the generated backend, you need to add two more simple classes into your Android client: `GcmIntentService` and `GcmBroadcastReceiver`.

Here is the source code for `GcmIntentService.java`:

```java
public class GcmIntentService extends IntentService {

    public GcmIntentService() {
        super("GcmIntentService");
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        Bundle extras = intent.getExtras();
        GoogleCloudMessaging gcm = GoogleCloudMessaging.getInstance(this);
        // The getMessageType() intent parameter must be the intent you received
        // in your BroadcastReceiver.
        String messageType = gcm.getMessageType(intent);

        if (extras != null && !extras.isEmpty()) {  // has effect of unparcelling Bundle
            // Since we're not using two way messaging, this is all we really to check for
            if (GoogleCloudMessaging.MESSAGE_TYPE_MESSAGE.equals(messageType)) {
                Logger.getLogger("GCM_RECEIVED").log(Level.INFO, extras.toString());

                showToast(extras.getString("message"));
            }
        }
        GcmBroadcastReceiver.completeWakefulIntent(intent);
    }

    protected void showToast(final String message) {
        new Handler(Looper.getMainLooper()).post(new Runnable() {
            @Override
            public void run() {
                Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
            }
        });
    }
}
```

Similarly, here is the source code for `GcmBroadcastReceiver.java`:

```java
public class GcmBroadcastReceiver extends WakefulBroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // Explicitly specify that GcmIntentService will handle the intent.
        ComponentName comp = new ComponentName(context.getPackageName(),
                GcmIntentService.class.getName());
        // Start the service, keeping the device awake while it is launching.
        startWakefulService(context, (intent.setComponent(comp)));
        setResultCode(Activity.RESULT_OK);
    }
}
```

After adding these classes to your Android application, register them by adding the following snipped into your `AndroidManifest.xml` file (inside `<application>` tag).

```xml
<receiver
    android:name=".GcmBroadcastReceiver"
    android:permission="com.google.android.c2dm.permission.SEND" >
    <intent-filter>
        <action android:name="com.google.android.c2dm.intent.RECEIVE" />
        <category android:name="MY_PACKAGE" />
    </intent-filter>
</receiver>
<service android:name=".GcmIntentService" />
```

Do not forget to replace `MY_PACKAGE` in the snippet above with your package name.

## 2.5. Deploying the backend live to App Engine

If your backend is working locally, you can deploy it to Google App Engine. To begin with, associate your backend [Google Developers Console](https://console.developers.google.com) project which you created (or re-used) in step 2.1.

Go back to the Developers Console and note down the project ID (in the red rectangle below).

![Project ID in Google Developers Console](/doc/img/developer-console-project-id.png)


Then, open `<backend>/src/main/webapp/WEB-INF/appengine-web.xml` file in Android Studio and change
```xml
<application>myApplicationId</application>
```
to contain your real Project ID (in this case, again, "android-app-backend"):
```xml
<application>android-app-backend</application>
```

If you have started the local Java development server in an earlier step, stop it by opening "Run" tool window (1), choosing your backend run session (2) and pressing the red "Stop" button (3). 

![Stop local Java development server](/doc/img/stop-devappserver-helloworld.png)

Then, switch to the "Terminal" tab and execute `./gradlew backend:appengineUpdate` command:

![Deployment from terminal, step 1](/doc/img/update-helloworld-1.png)

If you are running this task for the first time, you will be prompted to sign-in with your Google Account. After choosing the account and signing-in, give permissions to Google App Engine's "appcfg" tool and copy-paste the generated key back into Terminal:

![App Engine permissions request](/doc/img/app-engine-permissions.png)

![Deployment from terminal, step 1](/doc/img/update-helloworld-2.png)

After you paste the key and hit Return, your backend will be deployed to App Engine and will be accessible live at [https://&lt;Project ID&gt;.appspot.com](https://cloud.google.com). (In this example, the backend would be hosted at [https://android-app-backend.appspot.com](https://android-app-backend.appspot.com).)

## 2.3. Testing against a deployed backend

Once you have deployed your backend to App Engine, you can connect your Android app to it by modifying `GcmRegistrationAsyncTask` class defined in section 2 above. In particular, replace the lines
```java
Registration.Builder builder = new Registration.Builder(AndroidHttp.newCompatibleTransport(), new AndroidJsonFactory(), null)
        .setRootUrl("http://10.0.2.2:8080/_ah/api/") // 10.0.2.2 is localhost's IP address in Android emulator
        .setGoogleClientRequestInitializer(new GoogleClientRequestInitializer() {
            @Override
            public void initialize(AbstractGoogleClientRequest<?> abstractGoogleClientRequest) throws IOException {
                abstractGoogleClientRequest.setDisableGZipContent(true);
            }
        });
```
with a single line
```java
Registration.Builder builder = new Registration.Builder(AndroidHttp.newCompatibleTransport(), new AndroidJsonFactory(), null);
```

At this point you should be all set to run your Android app in an emulator or on the physical device, and successfully communicate with your new App Engine backend!
